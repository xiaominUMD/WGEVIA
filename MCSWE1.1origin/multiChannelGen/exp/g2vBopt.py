import numpy as np
import os
import sys
import csv
from hyperopt import STATUS_OK

# 2 optimizable parameter. enter multiple element to use Bopt

multiRunInfo = "./result/runInfo.csv"


def objFunc(params,modelNo = '2'):
	"""
	Function called by bayesian optimazation
	Optimization try different combination of input parameters and record results

	parameters:
	numOfT: number of thresholds 
	singleDim: dimension for single channel's feature generated by SG2V 
	wliter: number of iteration done in feature extraction in SG2V algorithm 
	modelNo: a fixed parameter to choose model 
		'0' : single hidden layer MLP
		'1' : multiple hidden layer MLP
		'2' : multiple hidden layer MLP with more units in each layer
		'3' : 1DCNN

	"""

	#print paras:
	Tprint = params['numOfT']
	wliter = params['wliter']
	DimPrint = params['singleDim']
	print("Current run numOfT: "+str(Tprint)+" singleDim: "+str(DimPrint)+" wlIteration: "+str(wliter))
	numOfT = params.get('numOfT')
	singleDim = params.get('singleDim')
	lof = "./runtimeRecord/lastLoss.csv"
	record = "./result/mcsweACC.csv"
	
	#call main script g2vpre with current inputs
	#argv[1] = train or inference
	#argv[2] = isPosT
	#argv[3] = isRangeCut
	#argv[4] = isAbs
	#argv[5] = mode of parallel
	#argv[6] = corenum
	
	print('arguments amount: '+str(len(sys.argv)))
	if len(sys.argv) == 10:
		CORENUM = sys.argv[6]
		os.system("cd ../src\npython3 g2vpre.py " + str(numOfT) + " json " + str(singleDim) + " " + str(
			wliter) + " " + modelNo + " "
				  + sys.argv[1] + " "
				  + sys.argv[2] + " "
				  + sys.argv[3] + " "
				  + sys.argv[4] + " "
				  + sys.argv[5] +" "+ CORENUM)
	else:
		os.system("cd ../src\npython3 g2vpre.py " + str(numOfT) + " json " + str(singleDim) + " " + str(
			wliter) + " " + modelNo + " "
				  + sys.argv[1] + " "
				  + sys.argv[2] + " "
				  + sys.argv[3] + " "
				  + sys.argv[4] + " "
				  + sys.argv[5])

	RE = {}
	newary = []
	indx = 0
	
	#check results saved in file lof
	with open(lof) as csvfile:
		spamreader = csv.reader(csvfile, delimiter=',')
		for row in spamreader:
			RE[str(indx)] = row[0]
			indx = indx + 1
	csvfile.close()
	lastLoss = RE['0']
	acc = RE['1']
	recordstr = "acc: "+str(acc)+" lastlost: "+str(lastLoss)+" numOfT: "+str(Tprint)+" singleDim: "+str(DimPrint)+" wliter: "+str(wliter)
	newary.append(recordstr)

	#save acc result of current optimization step to record file
	with open(record, 'a', newline='') as csvfile:
	    spamwriter = csv.writer(csvfile)
	    for i in range(len(newary)):
	        spamwriter.writerow([newary[i]])
	csvfile.close()

	return {'loss': lastLoss, 'acc': acc, 'status': STATUS_OK}

#import necesasry libs for beyasian optimization
from hyperopt import tpe
tpe_algorithm = tpe.suggest
from hyperopt import Trials
# Trials object to track progress
bayes_trials = Trials()
from hyperopt import fmin
from hyperopt import hp

# Define parameters for optimization
# put more item in array if user want bayesian opt examine more possible input values

dstr = sys.argv[len(sys.argv)-2].split(',')
nTstr = sys.argv[len(sys.argv)-3].split(',')
wstr = sys.argv[len(sys.argv)-1].split(',')

nT = [int(i) for i in nTstr]
d = [int(i) for i in dstr]
w = [int(i) for i in wstr]
print('Input nT is :'+str(nT))
print('Input d is :'+str(d))
print('Input w is :'+str(w))

wliter = w

space = {
    'wliter': hp.choice('wliter',wliter),
    'numOfT': hp.choice('numOfT',nT),
    'singleDim': hp.choice('singleDim', d),
}
# number of total optimization run
# change this number if you have more than 1 candidate input combinations
run = [len(nT)*len(d)]
bayesianRecord = []

for maxAtp in run:
	best = fmin(fn = objFunc, space = space, algo = tpe.suggest, max_evals = maxAtp, trials = bayes_trials)
	recordLine = "Attempts "+str(maxAtp)+" numOfT: "+str(best['numOfT'])+" singleDim: "+str(best['singleDim'])
	bayesianRecord.append(recordLine)
	print(best)

# record all beyasian optimization runs with inputs and outputs
with open(multiRunInfo, 'a', newline='') as csvfile:
    spamwriter = csv.writer(csvfile)
    for i in range(len(bayesianRecord)):
        spamwriter.writerow([bayesianRecord[i]])

csvfile.close()
